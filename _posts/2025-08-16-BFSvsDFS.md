---
layout: post
title:  "BFS vs DFS"
date:   2025-08-16 16:06:01 -0400
permalink: /:categories/:day/:month/:year/:title.html
tag: post_url
---

# What is BFS and DFS?
BFS (Breadth First Search) and DFS (Depth First Search) are search algorithms used to search for a target node or traverse an entire graph.

```
Traversal: The process of visitng every node of in a graph.
Search: The process of finding a specific target node, and stopping once it is found.
```

# BFS - Breadth First Search 
BFS works by exploring a graph level by level. It starts at a designated node, marks it as visited, and then adds all of its immediate neighbors to a queue. The algorithm then proceeds by taking the first node out of the queue, marking it as visited, and adding its unvisited neighbors to the end of the queue. This process continues until the queue is empty or the target node is found. Because it uses a queue data structure, BFS follows a First-In, First-Out (FIFO) approach.

## BFS Traversal Example
This image illustrates how BFS would traverse a binary tree and an undirected graph, exploring nodes at each level before moving to the next.

![BFS Traversal Order example - Binary Tree and Undirected Graph](/images/1_BFS_Traversal_Order_Example.png)

## Psuedocode for BFS Traversal 
```
vistedSet = []
queue = []

queue.append(start_node)
visitedSet.add(start_node)

while queue not empty{
    curr_node = queue.pop(0)
    
    for neighbor in curr_node{
        if (neighbor not in visitedSet){
            queue.append(neighbor)
            visitedSet.add(neighbor)
        }
    }
}
```

## Advantages of BFS
1. Guarantees Shortest Path: Because BFS explores level by level, it is guaranteed to find the shortest path from the start node to the target node in an unweighted graph. This is especially useful in undirected graphs where multiple paths may exist.
2. Completeness: If there is a solution that exists, BFS is guaranteed to find it  

## Disadvantages of BFS
1. Inefficient for deep targets: If the target node is far away from the start in a large, deep graph, because BFS searches level by level, it will take it a long time to find it, as it needs to explore every single level (think like a red wood tree - skinny but LONG). 

2. Could eventually get in an infinte loop if a cycle exists within a graph - If there is a cycle in the graph, BFS could continue to go  around in the circle "checking" to see if the children has been add to the visited set, with no way out.

## Runtime/Space Complexity
Runtime: 
O(V + E) - Number of total edges and verticies (or nodes) in the graph 
This represents the amount of nodes (verticies) visited along with the number of edges needed to find the solution or traverse the entire graph 

Space Complexity: 
O(V) - The number of verticies or nodes total
The total amount of space needed will be the total number of nodes(verticies) visted. This is because every node is either in the queue or the visited set. 

# DFS - Depth First Search 
DFS explores a graph by going as deep as possible along one path before backtracking to explore the next available path. It uses a stack (a Last-In, First-Out, or LIFO, data structure) to manage the nodes. 
DFS can be implmented recursively or with a stack 

***DFS Traversal Types: pre-order traversal, in-order traversal, and post-order traversal***

1. Pre-Order: vist, left, right 

2. In-order: left, visit, right

3. Post-Order: right, left, visit

To change the traversal order when programming DFS, you change the order in which values are added onto the stack.

## DFS Traversal example
Here's a visual showing DFS traversal on a binary tree and the corresponding orders for pre-order, in-order, and post-order: 
![DFS Traversal Order example - Binary Tree and Undirected Graph](/images/DFS_Traversal_Order.png)
## Pseudocode for DFS  
```
visitedSet = [] 
stack = []

stack.append(start_node)


while (stack is not empty){
    curr node = stack.pop()
    if (curr_node not in visitedSet){
        visitedSet.add(curr_node)
    }

    for each neighbor of curr_node{
        if (neightbor not in visitedSet){
            stack.push(neigbor) **[traversal order decided here]
        }
    }
}
```

## Advantages of DFS
1. Good for pathfinding: DFS is great if you want to explore all possible paths that exist within an undirected graph or tree. It will go as far deep as possible before it backtracks to the next node. 


## Disadvantages of DFS
1. It is not guaranteed to find the shortest possible path to a target node. If the first path it chooses contains the target node, it will find it and return that path as the solution, regardless if another path that is shorter exists. 
2. DFS would do poorly with dense graphs (think a graph that is like a bush) - if there was a node with one million children that each had many children, it would take a long time for DFS to go through the whole graph, and it could hypothetically go down one wrong path forever

## Runtime/Space Complexity
Runtime: 
O(V + E) - Process all nodes and edges (on average) to find the solution or traverse the entire graph

Space Complexity: 
O(V) - DFS only stores the nodes (verticies) that are currently on the stack, which is how it is able to backtrack. This can be as long as the longest branch with all it's nodes.

***Coming up soon...a demo with BFS and DFS***